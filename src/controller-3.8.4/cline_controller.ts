/*
 * When user wants to run a task in Roo-Code, they open the Roo-Code sidebar,
 * or open Roo-Code in a new tab.
 * 
 * The sidebar and each of the Roo-Code tabs have their own `ClineProvider` instance.
 * The provider is responsible for creating a `Cline` instance each time a task is run,
 * and for coordinating the process of running the task (i.e. showing messages to the user,
 * asking questions and providing answers to `Cline` instance).
 * 
 * It also provides the interface to run tools when requested by the `Cline` instance.
 * One of such tools is `new_task` which creates a new `Cline` instance and adds it to the stack
 * of `Cline` instances.
 */

// TODO: finish â†‘
// TODO: handle subtasks and task preemption

import { Channel, Waiters, Waiter, timeout } from '../async_utils';
import { Cline, ClineProvider, HistoryItem } from './cline';
import { Task } from '../roospawn';
import { MessagesTx, MessagesRx, Message, IClineController, ControllerEvents } from '../cline_controller';
import EventEmitter from 'events';

export interface ControllingTrackerParams {
    channel: MessagesTx;
    clineId?: string;
}

export class ClineController extends EventEmitter<ControllerEvents> implements IClineController {
    private _isAsking = false;

    constructor(private provider: ClineProvider, private tasks: Task[]) {
        super();

        const controller = this;

        // If the provider already has a `Cline` instance, attach state tracking to the instance.
        // The instance can be conducting only non-Roo-Spawn task, because `ClineController` is
        // created before starting the first Roo-Spawn task.
        const cline = provider.getCurrentCline();
        if (cline !== undefined) {
            this.attachTrackerToCline(cline);
        }

        // Override the `initClineWithTask` and `initClineWithHistoryItem` methods to attach state tracking
        // to all new `Cline` instances. Each task is conducted within a separate `Cline` instance.
        // The patched version of `initClineWithTask` gets additional `channel` parameter,
        // which is set only for Roo-Spawn tasks. This way we know which tasks are generated by Roo-Spawn,
        // and where to send related messages.

        // TODO: should we patch `initClineWithSubtask`?

        const oldInitClineWithTask = provider.initClineWithTask.bind(provider);
        const oldInitClineWithHistoryItem = provider.initClineWithHistoryItem.bind(provider);

        provider.initClineWithTask = async (task?: string, images?: string[], params?: ControllingTrackerParams) => {
            await oldInitClineWithTask(task, images);
            const cline = provider.getCurrentCline()!;
            this.emit('rootTaskStarted', cline.taskId);
            controller.attachTrackerToCline(cline, params);
        };

        provider.initClineWithHistoryItem = async (historyItem: HistoryItem) => {
            const clineId = historyItem.id;
            this.emit('rootTaskStarted', clineId);

            const task = this.tasks.find(task => task.clineId === clineId);

            await oldInitClineWithHistoryItem(historyItem);
            const cline = provider.getCurrentCline()!;

            if (task?.tx !== undefined) {
                let params: ControllingTrackerParams = { channel: task.tx };
                controller.attachTrackerToCline(cline, params);
                task.clineId = params.clineId;
            } else {
                controller.attachTrackerToCline(cline);
            }
        };
    }

    async canResumeTask(task: Task): Promise<boolean> {
        if (task.clineId === undefined) {
            return false;
        }

        const historyItem = (await this.provider.getTaskWithId(task.clineId)).historyItem;
        return historyItem !== undefined;
    }

    async resumeTask(task: Task): Promise<void> {
        if (task.clineId === undefined) {
            throw new Error('Task has no Cline ID');
        }

        const historyItem = (await this.provider.getTaskWithId(task.clineId)).historyItem;
        if (historyItem === undefined) {
            throw new Error('Task has no history item');
        }

        await this.provider.initClineWithHistoryItem(historyItem);
    }

    async startTask(task: Task): Promise<MessagesRx> {
        const { tx, rx } = Channel.create<Message>();

        const params: ControllingTrackerParams = { channel: tx };

        await this.provider.initClineWithTask(task.prompt, undefined, params);
        task.clineId = params.clineId;
        task.tx = tx;

        return rx;
    }

    async abortTaskStack(): Promise<void> {
        const cline = this.provider.getCurrentCline();
        if (cline === undefined) {
            return;
        }
        await cline.abortTask();
        await this.provider.postStateToWebview();
    }

    isBusy(): boolean {
        if (this._isAsking) {
            return true;
        }

        const cline = this.provider.getCurrentCline();
        if (cline === undefined) {
            return false;
        }
        if (cline.isStreaming) {
            return true;
        }
        if (cline.clineMessages[cline.clineMessages.length - 1]?.type === 'ask' && !cline.abort) {
            return true;
        }

        return false;
    }

    isAsking(): boolean {
        return this._isAsking;
    }

    attachTrackerToCline(cline: Cline, params?: ControllingTrackerParams) {
        let isRunning = true;
        const taskEnded = () => {
            if (isRunning) {
                // Lets assume that in Roo-Code 3.8.4 we do not create subtasks
                isRunning = false;
                this.emit('rootTaskEnded', cline.taskId);
            }
        };
        const taskRunning = () => {
            if (!isRunning) {
                // Lets assume that in Roo-Code 3.8.4 we do not create subtasks
                isRunning = true;
                this.emit('rootTaskStarted', cline.taskId);
            }
        };

        if (params !== undefined) {
            params.clineId = cline.taskId;
        }

        const tx = params?.channel;

        const oldSay: Cline['say'] = cline.say.bind(cline);
        const oldAsk: Cline['ask'] = cline.ask.bind(cline);
        const oldAbortTask: Cline['abortTask'] = cline.abortTask.bind(cline);

        cline.say = async (type, text, images, partial, checkpoint) => {
            this.emit('keepalive');
            if (type === 'user_feedback') {
                taskRunning();
            }

            await oldSay(type, text, images, partial, checkpoint);

            if (!partial) {
                const message: Message = { type: 'say', say: type, text, images };
                tx?.send(message);
    
                if (type === 'completion_result') {
                    tx?.send({ type: 'status', status: 'completed' });
                    taskEnded();
                }
            }
        };

        cline.ask = async (type, text, partial) => {
            this.emit('keepalive');
            if (!partial) {
                tx?.send({ type: 'ask', ask: type, text });
            }

            this._isAsking = true;
            const result = await oldAsk(type, text, partial);
            this._isAsking = false;

            if (result.response === 'messageResponse') {
                taskRunning();
            }
            this.emit('keepalive');
            return result;
        };

        cline.abortTask = async (isAbandoned: boolean = false) => {
            cline.say = oldSay;
            cline.ask = oldAsk;
            cline.abortTask = oldAbortTask;

            await oldAbortTask(isAbandoned);

            tx?.send({ type: 'status', status: 'aborted' });
            taskEnded();
        };
    }
}
