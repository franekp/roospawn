/*
 * When user wants to run a task in Roo-Code, they open the Roo-Code sidebar,
 * or open Roo-Code in a new tab.
 * 
 * The sidebar and each of the Roo-Code tabs have their own `ClineProvider` instance.
 * The provider is responsible for creating a `Cline` instance each time a task is run,
 * and for coordinating the process of running the task (i.e. showing messages to the user,
 * asking questions and providing answers to `Cline` instance).
 * 
 * It also provides the interface to run tools when requested by the `Cline` instance.
 * One of such tools is `new_task` which creates a new `Cline` instance and adds it to the stack
 * of `Cline` instances.
 */

// TODO: finish â†‘
// TODO: handle subtasks and task preemption

import { Channel, Waiters, Waiter, timeout } from '../async_utils';
import { Cline, ClineProvider, HistoryItem } from './cline';
import { Task } from '../roospawn';
import { MessagesTx, MessagesRx, Message, IClineController, UserTaskChange } from '../cline_controller';

export interface ControllingTrackerParams {
    channel: MessagesTx;
    timeoutMs: 'no_timeout' | number;
    clineId?: string;
}

export class ClineController implements IClineController {
    /// We set this flag to `true` when we know that some task is running within controlled `ClineProvider`.
    private busy: boolean = false;
    private waiters: Waiters = new Waiters();

    private _onUserChangedTask: ((change: UserTaskChange) => {
        timeoutMs: 'no_timeout' | number,
        waitBeforeStart?: Promise<void>
    }) = () => ({ timeoutMs: 'no_timeout' });

    onUserChangedTask(handler: (change: UserTaskChange) => {
        timeoutMs: 'no_timeout' | number,
        waitBeforeStart?: Promise<void>
    }): void {
        this._onUserChangedTask = handler;
    }

    constructor(private provider: ClineProvider, private tasks: Task[]) {
        const controller = this;

        // If the provider already has a `Cline` instance, attach state tracking to the instance.
        // The instance can be conducting only non-Roo-Spawn task, because `ClineController` is
        // created before starting the first Roo-Spawn task.
        const cline = provider.getCurrentCline();
        if (cline !== undefined) {
            this.attachObservingTrackerToCline(cline, 'no_timeout');
        }

        // Override the `initClineWithTask` and `initClineWithHistoryItem` methods to attach state tracking
        // to all new `Cline` instances. Each task is conducted within a separate `Cline` instance.
        // The patched version of `initClineWithTask` gets additional `channel` parameter,
        // which is set only for Roo-Spawn tasks. This way we know which tasks are generated by Roo-Spawn,
        // and where to send related messages.

        // TODO: should we patch `initClineWithSubtask`?

        const oldInitClineWithTask = provider.initClineWithTask.bind(provider);
        const oldInitClineWithHistoryItem = provider.initClineWithHistoryItem.bind(provider);

        provider.initClineWithTask = async (task?: string, images?: string[], params?: ControllingTrackerParams) => {
            this.busy = true;

            let timeoutMs: 'no_timeout' | number = 'no_timeout';
            if (params === undefined) {
                // Currently in onUserChangedTask('start_untracked_task') we always return
                // `{ timeoutMs: 'no_timeout', waitBeforeStart: undefined }`, but we do handle
                // this case generically, so that we are free to change this behaviour in the future.
                const handler = this._onUserChangedTask({ type: 'start_untracked_task' });
                timeoutMs = handler.timeoutMs;
                if (handler.waitBeforeStart !== undefined) {
                    await handler.waitBeforeStart;
                }
            }

            await oldInitClineWithTask(task, images);
            const cline = provider.getCurrentCline()!;

            if (params !== undefined) {
                controller.attachControllingTrackerToCline(cline, params);
            } else {
                controller.attachObservingTrackerToCline(cline, timeoutMs);
            }
        };

        provider.initClineWithHistoryItem = async (historyItem: HistoryItem, timeoutMs?: 'no_timeout' | number) => {
            this.busy = true;
            const clineId = historyItem.id;

            const task = this.tasks.find(task => task.clineId === clineId);

            // If timeoutMs is provided, it means that the resume is done by Roospawn, not by the user.
            if (timeoutMs === undefined && task?.tx !== undefined) {
                const handler = this._onUserChangedTask({ type: 'resume_tracked_task', task });
                timeoutMs = handler.timeoutMs;
                if (handler.waitBeforeStart !== undefined) {
                    await handler.waitBeforeStart;
                }
            } else if (timeoutMs === undefined) {
                // Currently in onUserChangedTask('resume_untracked_task') we always return
                // `{ timeoutMs: 'no_timeout', waitBeforeStart: undefined }`, but we do handle
                // this case generically, so that we are free to change this behaviour in the future.
                const handler = this._onUserChangedTask({ type: 'resume_untracked_task' });
                timeoutMs = handler.timeoutMs;
                if (handler.waitBeforeStart !== undefined) {
                    await handler.waitBeforeStart;
                }
            }

            await oldInitClineWithHistoryItem(historyItem);
            const cline = provider.getCurrentCline()!;

            if (task?.tx !== undefined) {
                let params: ControllingTrackerParams = {
                    channel: task.tx, timeoutMs,
                };
                controller.attachControllingTrackerToCline(cline, params);
                task.clineId = params.clineId;
            } else {
                controller.attachObservingTrackerToCline(cline, timeoutMs);
            }
        };
    }

    async waitUntilNotBusy(): Promise<void> {
        // We can run a Roo-Spawn task only if there is no other task running in the `ClineProvider`.
        // The waiter's condition is best effort to check whether some task is running in the provider.
        let waiter = new Waiter(() => {
            const cline = this.provider.getCurrentCline();
            return !this.busy
                && !cline?.isStreaming
                && !(cline?.clineMessages[-1]?.type === 'ask' && !cline?.abort);
        });
        this.waiters.add(waiter);
        await waiter.wait();
    }

    async canResumeTask(task: Task): Promise<boolean> {
        if (task.clineId === undefined) {
            return false;
        }

        const historyItem = (await this.provider.getTaskWithId(task.clineId)).historyItem;
        return historyItem !== undefined;
    }

    async resumeTask(task: Task, options: {timeoutMs: 'no_timeout' | number}): Promise<void> {
        if (task.clineId === undefined) {
            throw new Error('Task has no Cline ID');
        }

        const historyItem = (await this.provider.getTaskWithId(task.clineId)).historyItem;
        if (historyItem === undefined) {
            throw new Error('Task has no history item');
        }

        if (task.status !== 'running') {
            // We rely on the fact that when Roospawn resumes a task, it marks it as "running" before,
            // so we can distinguish between resuming by Roospawn and resuming by the user.
            throw new Error('For technical reasons, task must be marked as "running" before resuming');
        }

        await this.provider.initClineWithHistoryItem(historyItem, options.timeoutMs);
    }

    async startTask(task: Task, options: {timeoutMs: 'no_timeout' | number}): Promise<MessagesRx> {
        const { tx, rx } = Channel.create<Message>();

        const params: ControllingTrackerParams = {
            channel: tx,
            timeoutMs: options.timeoutMs,
        };

        await this.provider.initClineWithTask(task.prompt, undefined, params);
        task.clineId = params.clineId;
        task.tx = tx;

        return rx;
    }

    attachControllingTrackerToCline(cline: Cline, params: ControllingTrackerParams) {
        console.info("Attaching controlling tracker to Cline: ", cline);
        // We can set busy to false only once.
        let canSetBusy = true;
        const setBusy = (busy: boolean) => {
            if (canSetBusy) {
                canSetBusy = busy;
                this.busy = busy;
                if (busy === false) {
                    this.waiters.wake();
                }
            }
        };

        params.clineId = cline.taskId;

        const oldSay: Cline['say'] = cline.say.bind(cline);
        const oldAsk: Cline['ask'] = cline.ask.bind(cline);
        const oldAbortTask: Cline['abortTask'] = cline.abortTask.bind(cline);

        const { channel, timeoutMs } = params;

        cline.say = async (type, text, images, partial, checkpoint) => {
            await oldSay(type, text, images, partial, checkpoint);

            if (partial === false || partial === undefined) {
                const message: Message = { type: 'say', say: type, text, images };
                channel.send(message);

                if (type === 'completion_result') {
                    cline.say = oldSay;
                    cline.ask = oldAsk;
                    cline.abortTask = oldAbortTask;

                    channel.send({ type: 'status', status: 'completed' });
                    setBusy(false);
                }
            }
        };

        cline.ask = async (type, text, partial) => {
            if (partial === false || partial === undefined) {
                channel.send({ type: 'ask', ask: type, text });
            }

            const askPromise = oldAsk(type, text, partial);
            const result = await timeout(timeoutMs, askPromise);
            if (result.reason === 'timeout') {
                cline.say = oldSay;
                cline.ask = oldAsk;
                cline.abortTask = oldAbortTask;

                channel.send({ type: 'status', status: 'asking' });
                // Allow other tasks to run.
                // Running another task will call `ClineProvider.initClineWithTask`,
                // which internally aborts the current task.
                setBusy(false);
            }

            return await askPromise;
        };

        cline.abortTask = async (isAbandoned: boolean = false) => {
            cline.say = oldSay;
            cline.ask = oldAsk;
            cline.abortTask = oldAbortTask;

            await oldAbortTask(isAbandoned);

            channel.send({ type: 'status', status: 'aborted' });
            setBusy(false);
        };
    }

    // Currently we always pass 'no_timeout', but for completeness we implement the timeout,
    // so that we are free to change this behaviour in the future.
    attachObservingTrackerToCline(cline: Cline, timeoutMs: 'no_timeout' | number) {
        // We can set busy to false only once.
        let canSetBusy = true;
        const setBusy = (busy: boolean) => {
            if (canSetBusy) {
                canSetBusy = busy;
                this.busy = busy;
                if (busy === false) {
                    this.waiters.wake();
                }
            }
        };

        const oldSay: Cline['say'] = cline.say.bind(cline);
        const oldAsk: Cline['ask'] = cline.ask.bind(cline);
        const oldAbortTask: Cline['abortTask'] = cline.abortTask.bind(cline);

        cline.say = async (type, text, images, partial, checkpoint) => {
            await oldSay(type, text, images, partial, checkpoint);

            if (partial === false || partial === undefined) {
                if (type === 'completion_result') {
                    cline.say = oldSay;
                    cline.ask = oldAsk;
                    cline.abortTask = oldAbortTask;
                    setBusy(false);
                }
            }
        };

        cline.ask = async (type, text, partial) => {
            const askPromise = oldAsk(type, text, partial);
            const result = await timeout(timeoutMs, askPromise);
            if (result.reason === 'timeout') {
                cline.say = oldSay;
                cline.ask = oldAsk;
                cline.abortTask = oldAbortTask;

                // Allow other tasks to run.
                // Running another task will call `ClineProvider.initClineWithTask`,
                // which internally aborts the current task.
                setBusy(false);
            }

            return await askPromise;
        };

        cline.abortTask = async (isAbandoned: boolean = false) => {
            cline.say = oldSay;
            cline.ask = oldAsk;
            cline.abortTask = oldAbortTask;

            await oldAbortTask(isAbandoned);

            setBusy(false);
        };
    }
}
